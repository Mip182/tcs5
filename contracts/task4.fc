#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";

global int default_value;

global int codeOfExclamation;
global int codeOfE;
global int codeOfS;
global int codeOfX;
global int codeOfQuestion;
global int start_x;
global int start_y;
global int end_x;
global int end_y;

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

tuple insert_tuple(tuple t, tuple x, int k) asm """
  // t x k
  SETINDEXVAR
""";

tuple insert_int(tuple t, int x, int k) asm """
  // t x k
  SETINDEXVAR
""";

tuple update_int(tuple was, int new_val, int x, int y) inline {
    tuple row = was.at(x);

    tuple new_row = insert_int(row, new_val, y);

    return insert_tuple(was, new_row, x);
}

global int N;

tuple get_the_same_tuple_int(int x, int n) asm """
    DUP
    N SETGLOB
    DEC
    REPEAT:<{	//  x
    DUP
  }>
    N GETGLOB TUPLEVAR
""";

tuple get_the_same_tuple_tuple(tuple x, int n) asm """
    DUP
    N SETGLOB
    DEC
    REPEAT:<{	//  x
    DUP
  }>
    N GETGLOB TUPLEVAR
""";

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    codeOfExclamation = 33;
    codeOfE = 83;
    codeOfS = 69;
    codeOfX = 88;
    codeOfQuestion = 63;

    start_x = -1;
    start_y = -1;
    end_x = -1;
    end_y = -1;

    if (n > 8) {
        default_value = (1 << 41);

        tuple d = get_the_same_tuple_tuple(get_the_same_tuple_int(default_value, m), n);

        {
            int i = 0;
            repeat (n) {
                tuple row = maze.at(i);

                int j = 0;
                repeat(m) {
                    int val = row.at(j);

                    if (val == codeOfS) {
                        start_x = i;
                        start_y = j;

                        d = update_int(d, 0 , i, j);
                    } elseif (val == codeOfE) {
                        end_x = i;
                        end_y = j;
                    }

                    j += 1;
                }

                i += 1;
            }
        }

        int set_size = 35;

        cell s = new_dict();

        s~udict_set(set_size, (start_x << 5) | start_y, "");
        while (true) {
            (s, int key, _, _) = s.udict_delete_get_min(set_size);

            int new_min_val = key & ((1 << 10) - 1);
            int pos_x = (new_min_val >> 5);
            int pos_y = new_min_val & ((1 << 5) - 1);

            int cur_min = d.at(pos_x).at(pos_y);

            if ((cur_min & 1) == 0) {
                cur_min >>= 1;

                int cur_min_0 = (cur_min >> 10);

                if ((pos_x == end_x) & (pos_y == end_y)) {
                    int new_pos_val = cur_min & ((1 << 10) - 1);
                    int new_pos_x = (new_pos_val >> 5);
                    int new_pos_y = new_pos_val & ((1 << 5) - 1);

                    pos_x = new_pos_x;
                    pos_y = new_pos_y;

                    while ((pos_x != start_x) | (pos_y != start_y)) {
                        maze = update_int(maze, codeOfExclamation, pos_x, pos_y);

                        int new_pos_val = (d.at(pos_x).at(pos_y) >> 1) & ((1 << 10) - 1);
                        int new_pos_x = new_pos_val >> 5;
                        int new_pos_y = new_pos_val & ((1 << 5) - 1);

                        pos_x = new_pos_x;
                        pos_y = new_pos_y;
                    }

                    return (cur_min_0 >> 20, (cur_min_0 & ((1 << 20) - 1)) >> 10, (cur_min_0 & ((1 << 10) - 1)), maze);
                }

                d = update_int(d, (cur_min << 1) | 1, pos_x, pos_y);

                int diff_x = (pos_x == 0) ? 0 : -1;
                int count_rep_x = 1 - diff_x + ((pos_x + 1 == n) ? 0 : 1);
                int count_rep_y = 1 + ((pos_y == 0) ? 0 : 1) + ((pos_y + 1 == m) ? 0 : 1);
                int diff_y_beg = (pos_y == 0) ? 0 : -1;
                repeat (count_rep_x) {
                    int x = pos_x + diff_x;
                    tuple row = d.at(x);
                    tuple row_maze = maze.at(x);
                    int diff_y = diff_y_beg;

                    repeat (count_rep_y) {
                        int y = pos_y + diff_y;

                        int val = row.at(y);

                        if ((val & 1) == 0) {
                            int char = row_maze.at(y);

                            int new_val = cur_min_0 + 1;

                            if (char == codeOfX) {
                                new_val += (1 << 20);
                            } elseif (char == codeOfQuestion) {
                                new_val += (1 << 10);
                            }

                            if ((val >> 11) > new_val) {
                                d = update_int(d, (((new_val << 10) | (pos_x << 5) | pos_y) << 1), x, y);

                                s~udict_set(set_size, (new_val << 10) | (x << 5) | y, "");
                            }
                        }

                        diff_y += 1;
                    }

                    diff_x += 1;
                }
            }

        }
    } else {
        default_value = (1 << 25);

        tuple d = get_the_same_tuple_tuple(get_the_same_tuple_int(default_value, m), n);

        {
            int i = 0;
            repeat (n) {
                tuple row = maze.at(i);

                int j = 0;
                repeat(m) {
                    int val = row.at(j);

                    if (val == codeOfS) {
                        start_x = i;
                        start_y = j;

                        d = update_int(d, 0 , i, j);
                    } elseif (val == codeOfE) {
                        end_x = i;
                        end_y = j;
                    }

                    j += 1;
                }

                i += 1;
            }
        }

        int set_size = 24;

        cell s = new_dict();

        s~udict_set(set_size, (start_x << 3) | start_y, "");
        while (true) {
            (s, int key, _, _) = s.udict_delete_get_min(set_size);

            int new_min_val = key & ((1 << 6) - 1);
            int pos_x = (new_min_val >> 3);
            int pos_y = new_min_val & ((1 << 3) - 1);

            int cur_min = d.at(pos_x).at(pos_y);

            if ((cur_min & 1) == 0) {
                cur_min >>= 1;

                int cur_min_0 = (cur_min >> 6);

                if ((pos_x == end_x) & (pos_y == end_y)) {
                    int new_pos_val = cur_min & ((1 << 6) - 1);
                    int new_pos_x = (new_pos_val >> 3);
                    int new_pos_y = new_pos_val & ((1 << 3) - 1);

                    pos_x = new_pos_x;
                    pos_y = new_pos_y;

                    while ((pos_x != start_x) | (pos_y != start_y)) {
                        maze = update_int(maze, codeOfExclamation, pos_x, pos_y);

                        int new_pos_val = (d.at(pos_x).at(pos_y) >> 1) & ((1 << 6) - 1);
                        int new_pos_x = new_pos_val >> 3;
                        int new_pos_y = new_pos_val & ((1 << 3) - 1);

                        pos_x = new_pos_x;
                        pos_y = new_pos_y;
                    }

                    if ((cur_min_0 >> 12) != 0) {
                        return (-1,0,0,null());
                    }

                    return (cur_min_0 >> 12, (cur_min_0 & ((1 << 12) - 1)) >> 6, (cur_min_0 & ((1 << 6) - 1)), maze);
                }

                d = update_int(d, (cur_min << 1) | 1, pos_x, pos_y);

                int diff_x = (pos_x == 0) ? 0 : -1;
                int count_rep_x = 1 - diff_x + ((pos_x + 1 == n) ? 0 : 1);
                int count_rep_y = 1 + ((pos_y == 0) ? 0 : 1) + ((pos_y + 1 == m) ? 0 : 1);
                int diff_y_beg = (pos_y == 0) ? 0 : -1;
                repeat (count_rep_x) {
                    int x = pos_x + diff_x;
                    tuple row = d.at(x);
                    tuple row_maze = maze.at(x);
                    int diff_y = diff_y_beg;

                    repeat (count_rep_y) {
                        int y = pos_y + diff_y;

                        int val = row.at(y);

                        if ((val & 1) == 0) {
                            int char = row_maze.at(y);

                            int new_val = cur_min_0 + 1;

                            if (char == codeOfX) {
                                new_val += (1 << 12);
                            } elseif (char == codeOfQuestion) {
                                new_val += (1 << 6);
                            }

                            if ((val >> 7) > new_val) {
                                d = update_int(d, (((new_val << 6) | (pos_x << 3) | pos_y) << 1), x, y);

                                s~udict_set(set_size, (new_val << 6) | (x << 3) | y, "");
                            }
                        }

                        diff_y += 1;
                    }

                    diff_x += 1;
                }
            }

        }
    }


    return (-1,0,0,null());
}

