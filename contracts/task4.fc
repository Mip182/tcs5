#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";

global int default_value;

global int codeOfExclamation;
global int codeOfE;
global int codeOfS;
global int codeOfX;
global int codeOfQuestion;
global int start_x;
global int start_y;
global int end_x;
global int end_y;

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

tuple insert_tuple(tuple t, tuple x, int k) asm """
  // t x k
  SETINDEXVAR
""";

tuple insert_int(tuple t, int x, int k) asm """
  // t x k
  SETINDEXVAR
""";

tuple update_int(tuple was, int new_val, int x, int y) inline {
    tuple row = was.at(x);

    tuple new_row = insert_int(row, new_val, y);

    return insert_tuple(was, new_row, x);
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;;    #X, #?, # of moves, used, which cell is parent
    ;;    int new_n = 6;
    ;;    int new_m = 6;
    ;;
    ;;    tuple new_maze = empty_tuple();
    ;;    repeat (n) {
    ;;        tuple cur = empty_tuple();
    ;;        repeat (m) {
    ;;            cur~tpush(63);
    ;;        }
    ;;
    ;;        new_maze~tpush(cur);
    ;;    }
    ;;
    ;;    new_maze = update_int(new_maze, 83, 0, 0);
    ;;    new_maze = update_int(new_maze, 69, new_n - 1, new_m - 1);
    ;;
    ;;    if ((n == new_n) & (m == new_m)) {
    ;;        maze = new_maze;
    ;;    }
    ;;
    ;;    if ((n != new_n) | (m != new_m) | (maze.at(0).at(0) != 83) | (maze.at(n - 1).at(m - 1) != 69)) {
    ;;        var (a, b, c, ddd) = solve(new_n, new_m, new_maze);
    ;;    }


;;    cur_min, par, used
    default_value = (1 << 41);

    codeOfExclamation = 33;
    codeOfE = 83;
    codeOfS = 69;
    codeOfX = 88;
    codeOfQuestion = 63;

    start_x = -1;
    start_y = -1;
    end_x = -1;
    end_y = -1;

    tuple d = empty_tuple();
    {
        tuple cur = empty_tuple();
        repeat (m) {
            cur~tpush(default_value);
        }
        repeat (n) {
            d~tpush(cur);
        }
    }

    {
        int i = 0;
        repeat (n) {
            tuple row = maze.at(i);

            int j = 0;
            repeat(m) {
                int val = row.at(j);

                if (val == codeOfS) {
                    start_x = i;
                    start_y = j;

                    d = update_int(d, 0 , i, j);
                } elseif (val == codeOfE) {
                    end_x = i;
                    end_y = j;
                }

                j += 1;
            }

            i += 1;
        }
    }

    cell s = new_dict();

    s~udict_set(40, start_x * m + start_y, "");

    while(true) {
        (int key, _, _) = s.udict_get_min?(40);

        int new_min_val = key & ((1 << 10) - 1);
        int pos_x = new_min_val / m;
        int pos_y = new_min_val % m;

        int cur_min = d.at(pos_x).at(pos_y);

        if ((cur_min & 1) == 0) {
            cur_min >>= 1;

            int cur_min_0 = (cur_min >> 10);

            if ((pos_x == end_x) & (pos_y == end_y)) {
                int new_pos_val = cur_min & ((1 << 10) - 1);
                int new_pos_x = new_pos_val / m;
                int new_pos_y = new_pos_val % m;

                pos_x = new_pos_x;
                pos_y = new_pos_y;

                while ((pos_x != start_x) | (pos_y != start_y)) {
                    maze = update_int(maze, codeOfExclamation, pos_x, pos_y);

                    int new_pos_val = (d.at(pos_x).at(pos_y) >> 1) & ((1 << 10) - 1);
                    int new_pos_x = new_pos_val / m;
                    int new_pos_y = new_pos_val % m;

                    pos_x = new_pos_x;
                    pos_y = new_pos_y;
                }

                return (cur_min_0 >> 20, (cur_min_0 & ((1 << 20) - 1)) >> 10, (cur_min_0 & ((1 << 10) - 1)), maze);
            }

            s~udict_delete?(40, key);

            d = update_int(d, (cur_min >> 1) | 1, pos_x, pos_y);

            int diff_x = -1;
            repeat (3) {
                int x = pos_x + diff_x;
                if ((x >= 0) & (x < n)) {
                    tuple row = d.at(x);
                    tuple row_maze = maze.at(x);
                    int diff_y = -1;

                    repeat (3) {
                        int y = pos_y + diff_y;

                        if ((y >= 0) & (y < m)) {
                            int val = row.at(y);

                            if ((val & 1) == 0) {
                                int char = row_maze.at(y);

                                int isX = 0;
                                int isQuestionmark = 0;

                                if (char == codeOfX) {
                                    isX = 1;
                                } elseif (char == codeOfQuestion) {
                                    isQuestionmark = 1;
                                }

                                int new_val = cur_min_0 + (isX << 20) + (isQuestionmark << 10) + 1;

                                if ((val >> 11) > new_val) {
                                    d = update_int(d, (((new_val << 10) + pos_x * m + pos_y) << 1), x, y);

                                    s~udict_set(40,(new_val << 10) + x * m + y, "");
                                }
                            }
                        }

                        diff_y += 1;
                    }
                }

                diff_x += 1;
            }
        } else {
            s~udict_delete?(40, key);
        }

    }

    return (-1,0,0,null());
}
