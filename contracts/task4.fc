#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

tuple insert_tuple(tuple t, tuple x, int k) asm """
  // t x k
  SETINDEXVAR
""";

tuple insert_int(tuple t, int x, int k) asm """
  // t x k
  SETINDEXVAR
""";

tuple update(tuple was, tuple new_val, int x, int y) inline {
    tuple row = was.at(x);

    tuple new_row = insert_tuple(row, new_val, y);

    return insert_tuple(was, new_row, x);
}

tuple update_int(tuple was, int new_val, int x, int y) inline {
    tuple row = was.at(x);

    tuple new_row = insert_int(row, new_val, y);

    return insert_tuple(was, new_row, x);
}

int is_less(tuple a, tuple b) inline {
    int x = a.at(0);
    int y = b.at(0);

    if (x > y) {
        return true;
    } elseif (x == y) {
        x = a.at(1);
        y = b.at(1);

        if (x > y) {
            return true;
        } elseif (x == y) {
            x = a.at(2);
            y = b.at(2);

            return x > y;
        }
    }

    return false;
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
;;    #X, #?, # of moves, used, which cell is parent
;;    int new_n = 6;
;;    int new_m = 6;
;;
;;    tuple new_maze = empty_tuple();
;;    repeat (n) {
;;        tuple cur = empty_tuple();
;;        repeat (m) {
;;            cur~tpush(63);
;;        }
;;
;;        new_maze~tpush(cur);
;;    }
;;
;;    new_maze = update_int(new_maze, 83, 0, 0);
;;    new_maze = update_int(new_maze, 69, new_n - 1, new_m - 1);
;;
;;    if ((n == new_n) & (m == new_m)) {
;;        maze = new_maze;
;;    }
;;
;;    if ((n != new_n) | (m != new_m) | (maze.at(0).at(0) != 83) | (maze.at(n - 1).at(m - 1) != 69)) {
;;        var (a, b, c, ddd) = solve(new_n, new_m, new_maze);
;;    }


    tuple default_value = to_tuple([1000, 1000, 1000, -1, -1]);

    int codeOfExclamation = 33;
    int codeOfE = 83;
    int codeOfS = 69;
    int codeOfX = 88;
    int codeOfQuestion = 63;

    int start_x = -1;
    int start_y = -1;
    int end_x = -1;
    int end_y = -1;

    tuple d = empty_tuple();
    repeat (n) {
        tuple cur = empty_tuple();
        repeat (m) {
            cur~tpush(to_tuple([1000, 1000, 1000, -1, -1]));
        }

        d~tpush(cur);
    }

    tuple queue = null();

    {
        int i = 0;
        repeat (n) {
            tuple row = maze.at(i);

            int j = 0;
            repeat(m) {
                int val = row.at(j);

                if (val == codeOfS) {
                    start_x = i;
                    start_y = j;

                    d = update(d,to_tuple([0, 0, 0, -1, -1]) , i, j);
                    queue = cons(i * m + j, queue);
                } elseif (val == codeOfE) {
                    end_x = i;
                    end_y = j;
                }

                j += 1;
            }

            i += 1;
        }
    }

    while (queue.null?() == false) {
        int front = queue~list_next();

        int pos_x = front / m;
        int pos_y = front % m;

        tuple cur_min = d.at(pos_x).at(pos_y);

        int cur_min_0 = cur_min.at(0);
        int cur_min_1 = cur_min.at(1);
        int cur_min_2 = cur_min.at(2);

        if ((pos_x == end_x) & (pos_y == end_y)) {
            int new_pos_x = d.at(pos_x).at(pos_y).at(4);
            int new_pos_y = d.at(pos_x).at(pos_y).at(5);

            pos_x = new_pos_x;
            pos_y = new_pos_y;

            while ((pos_x != start_x) | (pos_y != start_y)) {
                maze = update_int(maze, codeOfExclamation, pos_x, pos_y);

                new_pos_x = d.at(pos_x).at(pos_y).at(4);
                new_pos_y = d.at(pos_x).at(pos_y).at(5);

                pos_x = new_pos_x;
                pos_y = new_pos_y;
            }

            return (cur_min_0, cur_min_1, cur_min_2, maze);
        }

        int diff_x = -1;
        repeat(3) {
            int x = pos_x + diff_x;
            if ((x >= 0) & (x < n)) {
                tuple row = d.at(x);
                tuple row_maze = maze.at(x);
                int diff_y = -1;

                repeat (3) {
                    int y = pos_y + diff_y;

                    if ((y >= 0) & (y < m)) {
                        tuple val = row.at(y);

                        int char = row_maze.at(y);

                        int isX = 0;
                        int isQuestionmark = 0;

                        if (char == codeOfX) {
                            isX = 1;
                        } elseif (char == codeOfQuestion) {
                            isQuestionmark = 1;
                        }

                        tuple new_val = to_tuple([cur_min_0 + isX, cur_min_1 + isQuestionmark, cur_min_2 + 1, pos_x, pos_y]);

                        if (is_less(val, new_val)) {
                            d = update(d, new_val, x, y);
                            queue = cons(x * m + y, queue);
                        }
                    }

                    diff_y += 1;
                }
            }

            diff_x += 1;
        }
    }

    int pos_x = end_x;
    int pos_y = end_y;

    tuple cur_min = d.at(pos_x).at(pos_y);

    int cur_min_0 = cur_min.at(0);
    int cur_min_1 = cur_min.at(1);
    int cur_min_2 = cur_min.at(2);

    int new_pos_x = d.at(pos_x).at(pos_y).at(4);
    int new_pos_y = d.at(pos_x).at(pos_y).at(5);

    pos_x = new_pos_x;
    pos_y = new_pos_y;

    while ((pos_x != start_x) | (pos_y != start_y)) {
        maze = update_int(maze, codeOfExclamation, pos_x, pos_y);

        new_pos_x = d.at(pos_x).at(pos_y).at(4);
        new_pos_y = d.at(pos_x).at(pos_y).at(5);

        pos_x = new_pos_x;
        pos_y = new_pos_y;
    }

    return (cur_min_0, cur_min_1, cur_min_2, maze);

    return (-1,0,0,null());
}
