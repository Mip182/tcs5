#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";
(int) tlen (tuple t) asm "TLEN";

;; All the code in recv_internal, get_storage, wrap_storage, and version
;; serves as an example of the intended structure.

;; The provided code is an "empty wrapper." It:
;; + Parses "wrapped" incoming messages (discards versioning information)
;; + "Wraps" the call to the version-specific process_message
;; + Implements "get_storage" for version-specific get-methods
;; However, it does not yet implement any upgrade logic, which is your task.

;; The empty wrapper is provided to demonstrate
;; how version-specific code is intended to be "wrapped" and interacted with.
;; You may delete and rewrite as needed,
;; but the final implementation must adhere to the same structure

() recv_internal(int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    int expected_version = in_msg_body~load_uint(32);
    cell update_code = in_msg_body~load_maybe_ref();
    cell migrations = in_msg_body~load_dict();
    cell payload = in_msg_body~load_ref();

    ;; ---
    ;; here you should check if it's the first call or not based on `expected_version` as stated in the task
    ;; if it is the first call, wrap the storage and finish execution by returning from the function
    ;; ---
;;    if ((expected_version == 0) & (migrations.dict_empty?())) {
;;        set_code(update_code);
;;        set_c3(bless(update_code.begin_parse()));
;;        set_data(wrap_storage(1, get_data()));
;;        return ();
;;    }

    slice ds = get_data().begin_parse();
    cell storage = ds~load_ref();
;;    int current_version = ds~load_uint(32);

;;    if (current_version != expected_version) {
;;        (int key, slice val, int flag) = migrations.udict_get_min?(32);
;;
;;        cell m = new_dict();
;;
;;        int found_need = false;
;;
;;        m~udict_set(32, current_version, begin_cell().store_uint(-1, 32).end_cell().begin_parse());
;;
;;        while (flag) {
;;            (slice key_val, int f) = m.udict_get?(32, key);
;;
;;            if (f == true) {
;;                int new_version = val~load_uint(32);
;;
;;                if (new_version == expected_version) {
;;                    found_need = true;
;;                }
;;                else {
;;                    cell migration_code = val~load_maybe_ref();
;;
;;                    m~udict_set(32, new_version, begin_cell().store_uint(key, 32).store_maybe_ref(migration_code).end_cell().begin_parse());
;;                    (key, val, flag) = migrations.udict_get_next?(32, key);
;;                }
;;            } else {
;;                (key, val, flag) = migrations.udict_get_next?(32, key);
;;            }
;;        }
;;
;;        throw_unless(400, found_need);
;;
;;        cell migration_code = val~load_maybe_ref();
;;
;;        tuple actions = to_tuple([migration_code]);
;;
;;        while (key != -1) {
;;            (val, _) = m.udict_get?(32, key);
;;
;;            int prev = val~load_uint(32);
;;            migration_code = val~load_maybe_ref();
;;
;;            actions~tpush(migration_code);
;;
;;            key = prev;
;;        }
;;
;;        int tuple_len = actions.tlen();
;;
;;        int i = tuple_len;
;;
;;        repeat (tuple_len) {
;;            i -= 1;
;;
;;            cell now = actions.at(i);
;;
;;            slice now_slice = now.begin_parse();
;;
;;            if (now_slice.slice_empty?() == false) {
;;                set_code(now);
;;                set_c3(bless(now_slice));
;;                storage = migrate_one(storage);
;;            }
;;
;;        }
;;    }

    storage = process_message(storage, msg_value, balance, in_msg_full, payload.begin_parse());

    set_data(wrap_storage(expected_version, storage));
}

cell get_storage() {
    slice cs = get_data().begin_parse();

    cell storage = cs~load_ref();

    return storage;
}

cell wrap_storage(int version_id, cell storage) {
    return begin_cell()
    .store_ref(storage)
;;    .store_uint(version_id, 32)
    .end_cell();
}

int version() method_id {
    return -2;
;;    slice cs = get_data().begin_parse();

;;    return slice_data_empty?(cs) ? 0 : cs~load_uint(32);
}

;; <<<<< Custom version-specific code begins
;; This section (everything between << and >> characters) will be fully substituted for each version.
;; This is an IMPORTANT part, and these exact lines with <<<<< and >>>>> must be present in your code for the testing system to work correctly.
;; All the code provided here serves as an example of the version-code, which your update code must be compatible with.
;; Refer to the "3-example" directory for more version examples.

;; from counter-v0.fc
cell process_message(cell storage, int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    slice cs = storage.begin_parse();
    int current_amount = cs.preload_uint(32);
    return begin_cell().store_uint(current_amount + 1, 32).end_cell();
}

cell migrate_one(cell old_storage) { ;; it's just a placeholder that is required for correct compilation
    return old_storage;
}

;; Custom version-specific code ends >>>>>